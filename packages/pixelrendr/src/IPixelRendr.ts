/// <reference path="../typings/ChangeLinr.d.ts" />
/// <reference path="../typings/StringFilr.d.ts" />

/**
 * A single [red, green, blue, alpha] pixel's colors.
 */
export type IPixel = [number, number, number, number];

/**
 * A palette of potential pixel colors.
 */
export type IPalette = IPixel[];

/**
 * A base container for storing raw sprites and their renders.
 */
export interface ILibrary {
    /**
     * The original sources for the sprites.
     */
    raws: any;

    /**
     * Rendered sprites from the raw sources.
     */
    sprites?: IRenderLibrary;
}

/**
 * Rendered sprite data generated from a source sprite.
 */
export interface IRender {
    /**
     * The original raw command that generated this render.
     */
    source: ICommand;

    /**
     * Output sprites generated by the source.
     */
    sprites: IRenderSprites;

    /**
     * An optional filter to change colors by, if source is a "filter" command.
     */
    filter: IFilterAttributes;

    /**
     * Any containers storing this IRender.
     */
    containers: IRenderContainerListing[];
}

/**
 * Generated sprites stored within an IRender.
 */
export interface IRenderSprites {
    [i: string]: Uint8ClampedArray | ISpriteMultiple;
}

/**
 * References to contains that store an IRender.
 */
export interface IRenderContainerListing {
    /**
     * A container storing the listing's IRender.
     */
    container: IRenderLibrary;

    /**
     * The key under which the IRender is stored.
     */
    key: string;
}

/**
 * A searchable storage tree of IRenders.
 */
export interface IRenderLibrary {
    [i: string]: IRenderLibrary | IRender;
}

/**
 * Information for expanding a sprite. A PixelDrawr's IThing will often be passed
 * to satisfy this at runtime.
 */
export interface ISpriteAttributes {
    filter?: IFilter;
    [i: string]: number | IFilter;
}

/**
 * A raw sprite, as either the pixel String or Array of commands.
 */
export type ICommand = string | any[];

/**
 * A "filter" command, as ["filter", [source path], "<filter name>"].
 */
export type IFilterCommand = [string, string[], string];

/**
 * A "multiple" command, as ["multiple", "<direction>", <sprites>].
 */
export type IMultipleCommand = [string, string, ISpriteMultipleSettings];

/**
 * A "same" command, as ["same", [source path]].
 */
export type ISameCommand = [string, string[]];

export interface IFilter {
    0: string;
    1: {
        [i: string]: string;
    };
}

export interface IFilterContainer {
    [i: string]: IFilter;
}

export interface IFilterAttributes {
    filter: IFilter;
}

/**
 * Raw settings to generate an ISpriteMultiple.
 */
export interface ISpriteMultipleSettings {
    /**
     * Raw sprite component for the top section.
     */
    top?: string;

    /**
     * How many pixels tall the top section is, if it exists.
     */
    topheight?: number;

    /**
     * Raw sprite component for the right section.
     */
    right?: string;

    /**
     * How many pixels wide the right section is, if it exists.
     */
    rightwidth?: number;

    /**
     * Raw sprite component for the bottom section.
     */
    bottom?: string;

    /**
     * How many pixels tall the bottom section is, if it exists.
     */
    bottomheight?: number;

    /**
     * Raw sprite component for the left section.
     */
    left?: string;

    /**
     * How many pixels wide the left section is, if it exists.
     */
    leftwidth?: number;

    /**
     * Raw sprite component for the center section.
     */
    middle?: string;

    /**
     * Whether the center section should stretch to fill its space.
     */
    middleStretch?: boolean;
}

/**
 * Container for multiple sprite sections of Uint8ClampedArray of data.
 */
export interface ISpriteMultiple {
    /**
     * Storage for each internal Uint8ClampedArray sprite, keyed by container.
     */
    sprites: IClampedArraysContainer;

    /**
     * The direction of sprite, such as "horizontal".
     */
    direction: string;

    /**
     * How many pixels tall the top section is, if it exists.
     */
    topheight: number;

    /**
     * How many pixels wide the right section is, if it exists.
     */
    rightwidth: number;

    /**
     * How many pixels tall the bottom section is, if it exists.
     */
    bottomheight: number;

    /**
     * How many pixels wide the left section is, if it exists.
     */
    leftwidth: number;

    /**
     * Whether the middle section should be stretched to fill the remaining
     * space instead of filling as a pattern.
     */
    middleStretch: boolean;
}

/**
 * Storage for an ISpriteMultiple's generated sprites.
 */
export interface IClampedArraysContainer {
    [i: string]: Uint8ClampedArray;
}

export interface IGeneralSpriteGenerator {
    (render: IRender, key: string, attributes: any): Uint8ClampedArray | ISpriteMultiple;
}

export interface IPixelRendrEncodeCallback {
    (result: string, image: HTMLImageElement, ...args: any[]): any;
}

/**
 * Settings to initialize a new IPixelRendr.
 */
export interface IPixelRendrSettings {
    /**
     * The default palette of colors to use for sprites.
     */
    paletteDefault: IPalette;

    /**
     * A nested library of sprites to process.
     */
    library?: any;

    /**
     * Filters that may be used by sprites in the library.
     */
    filters?: IFilterContainer;

    /**
     * An amount to expand sprites by when processing (by default, 1 for not at
     * all).
     */
    scale?: number;

    /**
     * What sub-class in decode keys should indicate a sprite is to be flipped
     * vertically (by default, "flip-vert").
     */
    flipVert?: string;

    /**
     * What sub-class in decode keys should indicate a sprite is to be flipped
     * horizontally (by default, "flip-vert").
     */
    flipHoriz?: string;

    /**
     * What key in attributions should contain sprite widths (by default, 
     * "spriteWidth").
     */
    spriteWidth?: string;

    /**
     *  What key in attributions should contain sprite heights (by default, 
     * "spriteHeight").
     */
    spriteHeight?: string;

    /**
     * A replacement for window.Uint8ClampedArray, if desired.
     */
    Uint8ClampedArray?: typeof Uint8ClampedArray;
}

/**
 * Compresses images into text blobs in real time with fast cached lookups.
 */
export interface IPixelRendr {
    /**
     * @returns The default colors used for palettes in sprites.
     */
    getPaletteDefault(): IPalette;

    /**
     * @returns The base container for storing sprite information.
     */
    getBaseLibrary(): any;

    /**
     * @returns The amount to expand sprites by when processing.
     */
    getScale(): number;

    /**
     * @returns The StringFilr interface on top of the base library.
     */
    getBaseFiler(): StringFilr.IStringFilr<any>;

    /**
     * @returns The processor that turns raw strings into partial sprites.
     */
    getProcessorBase(): ChangeLinr.IChangeLinr;

    /**
     * @returns The processor that converts partial sprites and repeats rows.
     */
    getProcessorDims(): ChangeLinr.IChangeLinr;

    /**
     * @returns The processor that takes real images and compresses their data 
     *          into sprite Strings.
     */
    getProcessorEncode(): ChangeLinr.IChangeLinr;

    /**
     * Resets the nested library of sprite sources.
     * 
     * @param library   A new nested library of sprites.
     */
    resetLibrary(library: any): void;

    /**
     * Resets an individual rendered sprite.
     * 
     * @param key   The key of the sprite to render.
     */
    resetRender(key: string): void;

    /**
     * Retrieves the base sprite under the given key.
     * 
     * @param key   A key for a base sprite.
     * @returns The base sprite for the key. This will be a Uint8ClampedArray 
     *          or SpriteMultiple if a sprite is found, or the deepest matching 
     *          Object in the library if not.
     */
    getSpriteBase(key: string): Uint8ClampedArray | ISpriteMultiple;

    /**
     * Standard render function. Given a key, this finds the raw information via
     * BaseFiler and processes it using ProcessorDims. Attributes are needed so
     * the ProcessorDims can stretch it on width and height.
     * 
     * @param key   The general key for the sprite.
     * @param attributes   Additional attributes for the sprite; width and height 
     *                     Numbers are required.
     * @returns A sprite for the given key and attributes.
     */
    decode(key: string, attributes: any): Uint8ClampedArray | ISpriteMultiple;

    /**
     * Encodes an image into a sprite via ProcessorEncode.process.
     * 
     * @param image   An image to encode.
     * @param callback   An optional callback to call with image and the result.
     * @param args   Any additional arguments to pass to the callback.
     * @returns The resultant sprite.
     */
    encode(image: HTMLImageElement, callback?: IPixelRendrEncodeCallback, ...args: any[]): string;

    /**
     * Fetches an image from a source and encodes it into a sprite via 
     * ProcessEncode.process. An HtmlImageElement is created and given an onload
     * of this.encode.
     * 
     * @param uri   The URI of an image to encode.
     * @param callback   A callback to call on the results.
     */
    encodeUri(uri: string, callback: IPixelRendrEncodeCallback): void;

    /**
     * Miscellaneous utility to generate a complete palette from raw image pixel
     * data. Unique [r,g,b,a] values are found using tree-based caching, and
     * separated into grayscale (r,g,b equal) and general (r,g,b unequal). If a
     * pixel has a=0, it's completely transparent and goes before anything else
     * in the palette. Grayscale colors come next in order of light to dark, and
     * general colors come next sorted by decreasing r, g, and b in order.
     * 
     * @param data   The equivalent data from a context's getImageData(...).data.
     * @param forceZeroColor   Whether the palette should have a [0,0,0,0] color 
     *                         as the first element even if data does not contain 
     *                         it (by default, false).
     * @param giveArrays   Whether the resulting palettes should be converted to 
     *                     Arrays (by default, false).
     * @returns A working palette that may be used in sprite settings (Array[] if
     *          giveArrays is true).
     */
    generatePaletteFromRawData(data: Uint8ClampedArray, forceZeroColor?: boolean, giveArrays?: boolean): Uint8ClampedArray[];

    /**
     * Copies a stretch of members from one Uint8ClampedArray or number[] to
     * another. This is a useful utility Function for code that may use this 
     * PixelRendr to draw its output sprites, such as PixelDrawr.
     * 
     * @param source   An Array-like source to copy from.
     * @param destination   An Array-like destination to copy to.
     * @param readloc   Where to start reading from in the source.
     * @param writeloc   Where to start writing to in the source.
     * @param writelength   How many members to copy over.
     * @see http://www.html5rocks.com/en/tutorials/webgl/typed_arrays/
     * @see http://www.javascripture.com/Uint8ClampedArray
     */
    memcpyU8(
        source: Uint8ClampedArray | number[],
        destination: Uint8ClampedArray | number[],
        readloc?: number,
        writeloc?: number,
        writelength?: number): void;
}
